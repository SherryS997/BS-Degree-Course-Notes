<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>BS Degree Notes - Graph Theory Fundamentals</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="https://lalten.github.io/lmweb/style/latinmodern-roman.css">
<link rel="stylesheet" href="https://lalten.github.io/lmweb/style/latinmodern-sans.css">
<link rel="stylesheet" href="https://lalten.github.io/lmweb/style/latinmodern-mono.css">
</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../pages/ST/Week01.html">Software Testing</a></li><li class="breadcrumb-item"><a href="../../pages/ST/Week02.html">Week 2</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../../">BS Degree Notes</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="false">
 <span class="menu-text">Deep Learning</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/DL/Week01_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 1.1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/DL/Week01_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 1.2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/DL/Week02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/DL/Week03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 3</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/DL/Week04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 4</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/DL/Week05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 5</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/DL/Week06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 6</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
 <span class="menu-text">AI: Search Methods</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/AI/Week01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/AI/Week02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/AI/Week03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 3</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/AI/Week04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 4</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/AI/Week05.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 5</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/AI/Week06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 6</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true">
 <span class="menu-text">Software Testing</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week02.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Week 2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 3</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 4</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week06.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 6</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week07.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 7</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week08.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 8</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week09.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 9</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/ST/Week10.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 10</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
 <span class="menu-text">Software Engineering</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/SE/Week01.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/SE/Week02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/SE/Week03.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 3</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/SE/Week04.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 4</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false">
 <span class="menu-text">Reinforcement Learning</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/RL/Week01_1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 1.1</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/RL/Week01_2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 1.2</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../pages/RL/Week02.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Week 2</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#basics-of-graphs" id="toc-basics-of-graphs" class="nav-link active" data-scroll-target="#basics-of-graphs">Basics of Graphs</a>
  <ul class="collapse">
  <li><a href="#introduction-to-graphs" id="toc-introduction-to-graphs" class="nav-link" data-scroll-target="#introduction-to-graphs">Introduction to Graphs</a></li>
  <li><a href="#graph-components" id="toc-graph-components" class="nav-link" data-scroll-target="#graph-components">Graph Components</a>
  <ul class="collapse">
  <li><a href="#degree-of-a-vertex" id="toc-degree-of-a-vertex" class="nav-link" data-scroll-target="#degree-of-a-vertex">Degree of a Vertex</a></li>
  </ul></li>
  <li><a href="#control-flow-graphs" id="toc-control-flow-graphs" class="nav-link" data-scroll-target="#control-flow-graphs">Control Flow Graphs</a></li>
  <li><a href="#path-length-and-reachability" id="toc-path-length-and-reachability" class="nav-link" data-scroll-target="#path-length-and-reachability">Path, Length, and Reachability</a></li>
  <li><a href="#depth-first-search-dfs-and-breadth-first-search-bfs" id="toc-depth-first-search-dfs-and-breadth-first-search-bfs" class="nav-link" data-scroll-target="#depth-first-search-dfs-and-breadth-first-search-bfs">Depth First Search (DFS) and Breadth First Search (BFS)</a></li>
  <li><a href="#test-path-and-feasibility" id="toc-test-path-and-feasibility" class="nav-link" data-scroll-target="#test-path-and-feasibility">Test Path and Feasibility</a></li>
  <li><a href="#visiting-and-touring" id="toc-visiting-and-touring" class="nav-link" data-scroll-target="#visiting-and-touring">Visiting and Touring</a></li>
  <li><a href="#test-requirements-and-criteria" id="toc-test-requirements-and-criteria" class="nav-link" data-scroll-target="#test-requirements-and-criteria">Test Requirements and Criteria</a></li>
  <li><a href="#structural-coverage-criteria" id="toc-structural-coverage-criteria" class="nav-link" data-scroll-target="#structural-coverage-criteria">Structural Coverage Criteria</a></li>
  </ul></li>
  <li><a href="#graph-representation-and-breadth-first-search" id="toc-graph-representation-and-breadth-first-search" class="nav-link" data-scroll-target="#graph-representation-and-breadth-first-search">Graph Representation and Breadth-First Search</a>
  <ul class="collapse">
  <li><a href="#introduction-to-graph-representation" id="toc-introduction-to-graph-representation" class="nav-link" data-scroll-target="#introduction-to-graph-representation">Introduction to Graph Representation</a>
  <ul class="collapse">
  <li><a href="#graph-data-structures" id="toc-graph-data-structures" class="nav-link" data-scroll-target="#graph-data-structures">Graph Data Structures</a></li>
  <li><a href="#representation-methods" id="toc-representation-methods" class="nav-link" data-scroll-target="#representation-methods">Representation Methods</a></li>
  </ul></li>
  <li><a href="#breadth-first-search-bfs" id="toc-breadth-first-search-bfs" class="nav-link" data-scroll-target="#breadth-first-search-bfs">Breadth-First Search (BFS)</a>
  <ul class="collapse">
  <li><a href="#algorithm-overview" id="toc-algorithm-overview" class="nav-link" data-scroll-target="#algorithm-overview">Algorithm Overview</a></li>
  <li><a href="#example-execution-of-bfs" id="toc-example-execution-of-bfs" class="nav-link" data-scroll-target="#example-execution-of-bfs">Example Execution of BFS</a></li>
  <li><a href="#analysis-of-bfs" id="toc-analysis-of-bfs" class="nav-link" data-scroll-target="#analysis-of-bfs">Analysis of BFS</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#depth-first-search-dfs-in-graphs" id="toc-depth-first-search-dfs-in-graphs" class="nav-link" data-scroll-target="#depth-first-search-dfs-in-graphs">Depth First Search (DFS) in Graphs</a>
  <ul class="collapse">
  <li><a href="#overview-of-dfs" id="toc-overview-of-dfs" class="nav-link" data-scroll-target="#overview-of-dfs">Overview of DFS</a>
  <ul class="collapse">
  <li><a href="#pseudocode-for-dfs" id="toc-pseudocode-for-dfs" class="nav-link" data-scroll-target="#pseudocode-for-dfs">Pseudocode for DFS</a></li>
  <li><a href="#properties-of-dfs" id="toc-properties-of-dfs" class="nav-link" data-scroll-target="#properties-of-dfs">Properties of DFS</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#strongly-connected-components-scc" id="toc-strongly-connected-components-scc" class="nav-link" data-scroll-target="#strongly-connected-components-scc">Strongly Connected Components (SCC)</a>
  <ul class="collapse">
  <li><a href="#algorithm-for-scc" id="toc-algorithm-for-scc" class="nav-link" data-scroll-target="#algorithm-for-scc">Algorithm for SCC</a></li>
  </ul></li>
  <li><a href="#structural-coverage-criteria-1" id="toc-structural-coverage-criteria-1" class="nav-link" data-scroll-target="#structural-coverage-criteria-1">Structural Coverage Criteria</a>
  <ul class="collapse">
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#nodes-edges-and-paths" id="toc-nodes-edges-and-paths" class="nav-link" data-scroll-target="#nodes-edges-and-paths">Nodes, Edges, and Paths</a>
  <ul class="collapse">
  <li><a href="#node-coverage" id="toc-node-coverage" class="nav-link" data-scroll-target="#node-coverage">Node Coverage</a></li>
  <li><a href="#edge-coverage" id="toc-edge-coverage" class="nav-link" data-scroll-target="#edge-coverage">Edge Coverage</a></li>
  <li><a href="#edge-pair-coverage" id="toc-edge-pair-coverage" class="nav-link" data-scroll-target="#edge-pair-coverage">Edge Pair Coverage</a></li>
  </ul></li>
  <li><a href="#prime-path-coverage" id="toc-prime-path-coverage" class="nav-link" data-scroll-target="#prime-path-coverage">Prime Path Coverage</a>
  <ul class="collapse">
  <li><a href="#touring-with-side-trips-and-detours" id="toc-touring-with-side-trips-and-detours" class="nav-link" data-scroll-target="#touring-with-side-trips-and-detours">Touring with Side Trips and Detours</a></li>
  </ul></li>
  <li><a href="#round-trip-coverage" id="toc-round-trip-coverage" class="nav-link" data-scroll-target="#round-trip-coverage">Round Trip Coverage</a></li>
  </ul></li>
  <li><a href="#graphs-for-structural-coverage-criteria" id="toc-graphs-for-structural-coverage-criteria" class="nav-link" data-scroll-target="#graphs-for-structural-coverage-criteria">Graphs for Structural Coverage Criteria</a>
  <ul class="collapse">
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#structural-coverage-criteria-2" id="toc-structural-coverage-criteria-2" class="nav-link" data-scroll-target="#structural-coverage-criteria-2">Structural Coverage Criteria</a>
  <ul class="collapse">
  <li><a href="#node-coverage-and-edge-coverage" id="toc-node-coverage-and-edge-coverage" class="nav-link" data-scroll-target="#node-coverage-and-edge-coverage">1. Node Coverage and Edge Coverage</a></li>
  <li><a href="#edge-pair-coverage-1" id="toc-edge-pair-coverage-1" class="nav-link" data-scroll-target="#edge-pair-coverage-1">2. Edge Pair Coverage</a></li>
  <li><a href="#specified-path-coverage" id="toc-specified-path-coverage" class="nav-link" data-scroll-target="#specified-path-coverage">3. Specified Path Coverage</a></li>
  </ul></li>
  <li><a href="#prime-path-coverage-1" id="toc-prime-path-coverage-1" class="nav-link" data-scroll-target="#prime-path-coverage-1">Prime Path Coverage</a>
  <ul class="collapse">
  <li><a href="#prime-paths" id="toc-prime-paths" class="nav-link" data-scroll-target="#prime-paths">Prime Paths</a></li>
  <li><a href="#test-requirements-3" id="toc-test-requirements-3" class="nav-link" data-scroll-target="#test-requirements-3">Test Requirements</a></li>
  <li><a href="#prime-path-enumeration-algorithm" id="toc-prime-path-enumeration-algorithm" class="nav-link" data-scroll-target="#prime-path-enumeration-algorithm">Prime Path Enumeration Algorithm</a></li>
  </ul></li>
  <li><a href="#test-paths-for-prime-path-coverage" id="toc-test-paths-for-prime-path-coverage" class="nav-link" data-scroll-target="#test-paths-for-prime-path-coverage">Test Paths for Prime Path Coverage</a>
  <ul class="collapse">
  <li><a href="#algorithm-overview-2" id="toc-algorithm-overview-2" class="nav-link" data-scroll-target="#algorithm-overview-2">Algorithm Overview</a></li>
  <li><a href="#example-2" id="toc-example-2" class="nav-link" data-scroll-target="#example-2">Example</a></li>
  <li><a href="#optimality-challenge" id="toc-optimality-challenge" class="nav-link" data-scroll-target="#optimality-challenge">Optimality Challenge</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a>
  <ul class="collapse">
  <li><a href="#points-to-remember" id="toc-points-to-remember" class="nav-link" data-scroll-target="#points-to-remember">Points to Remember</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../../pages/ST/Week01.html">Software Testing</a></li><li class="breadcrumb-item"><a href="../../pages/ST/Week02.html">Week 2</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Graph Theory Fundamentals</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="basics-of-graphs" class="level1">
<h1>Basics of Graphs</h1>
<section id="introduction-to-graphs" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-graphs">Introduction to Graphs</h2>
<p>Graphs, as fundamental data structures, play a crucial role in software testing. The inception of graph theory dates back to 1736, when Leonard Euler addressed the “Seven Bridges of Konigsberg” problem. Graphs find applications not only in computer science and data science but also in diverse fields such as sociology, economics, chemistry, and biology.</p>
</section>
<section id="graph-components" class="level2">
<h2 class="anchored" data-anchor-id="graph-components">Graph Components</h2>
<p>A graph comprises vertices (nodes) denoted by the set <span class="math inline">\(V\)</span> and edges denoted by the set <span class="math inline">\(E\)</span>, where <span class="math inline">\(E\)</span> is a subset of <span class="math inline">\(V \times V\)</span> (the cartesian product of <span class="math inline">\(V\)</span> with itself). Graphs can be classified as undirected (lacking arrows on edges) or directed (with edges having directions). Self-loops, edges connecting a vertex to itself, add a special characteristic. While graphs can be finite or infinite, finite graphs are preferred for testing purposes.</p>
<section id="degree-of-a-vertex" class="level3">
<h3 class="anchored" data-anchor-id="degree-of-a-vertex">Degree of a Vertex</h3>
<p>The degree of a vertex is defined as the number of edges incident to it. In directed graphs, the degree is further categorized into in-degree (count of incoming edges) and out-degree (count of outgoing edges).</p>
</section>
</section>
<section id="control-flow-graphs" class="level2">
<h2 class="anchored" data-anchor-id="control-flow-graphs">Control Flow Graphs</h2>
<p>Control flow graphs are essential in software testing for modeling program control flow. An illustrative example includes a control flow graph for an if-else statement.</p>
</section>
<section id="path-length-and-reachability" class="level2">
<h2 class="anchored" data-anchor-id="path-length-and-reachability">Path, Length, and Reachability</h2>
<ul>
<li><strong>Path:</strong> A path represents a sequence of vertices connected by edges.</li>
<li><strong>Length of a Path:</strong> It corresponds to the number of edges in a given path.</li>
<li><strong>Reachability:</strong> This concept determines whether a vertex or edge is reachable from another within the graph.</li>
</ul>
</section>
<section id="depth-first-search-dfs-and-breadth-first-search-bfs" class="level2">
<h2 class="anchored" data-anchor-id="depth-first-search-dfs-and-breadth-first-search-bfs">Depth First Search (DFS) and Breadth First Search (BFS)</h2>
<p>DFS and BFS are algorithms crucial for reachability analysis in graphs.</p>
<ul>
<li><strong>DFS (Depth First Search):</strong> This algorithm explores as far as possible before backtracking.</li>
<li><strong>BFS (Breadth First Search):</strong> BFS explores level by level in a graph.</li>
</ul>
<p>These algorithms are instrumental in solving various reachability problems in graph theory.</p>
</section>
<section id="test-path-and-feasibility" class="level2">
<h2 class="anchored" data-anchor-id="test-path-and-feasibility">Test Path and Feasibility</h2>
<p>A test path is a sequence of vertices and edges starting from an initial vertex and ending at a final vertex. Feasible test paths are executable with valid test cases, while infeasible ones cannot be achieved.</p>
</section>
<section id="visiting-and-touring" class="level2">
<h2 class="anchored" data-anchor-id="visiting-and-touring">Visiting and Touring</h2>
<ul>
<li>A test path <strong>visits</strong> a vertex or edge when it includes them in the sequence.</li>
<li><strong>Touring</strong> is an equivalent concept for vertices and edges.</li>
</ul>
</section>
<section id="test-requirements-and-criteria" class="level2">
<h2 class="anchored" data-anchor-id="test-requirements-and-criteria">Test Requirements and Criteria</h2>
<ul>
<li><strong>Test Requirements:</strong> These specifications define properties to be tested, such as covering every if statement or loop.</li>
<li><strong>Test Criteria:</strong> Rules outlining how test requirements should be satisfied.</li>
</ul>
</section>
<section id="structural-coverage-criteria" class="level2">
<h2 class="anchored" data-anchor-id="structural-coverage-criteria">Structural Coverage Criteria</h2>
<p>Structural coverage criteria concentrate on graph structure without considering variables. An example is <strong>Branch Coverage,</strong> aiming to cover all branches in a graph.</p>
</section>
</section>
<section id="graph-representation-and-breadth-first-search" class="level1">
<h1>Graph Representation and Breadth-First Search</h1>
<section id="introduction-to-graph-representation" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-graph-representation">Introduction to Graph Representation</h2>
<section id="graph-data-structures" class="level3">
<h3 class="anchored" data-anchor-id="graph-data-structures">Graph Data Structures</h3>
<p>In the context of software testing, graphs serve as fundamental data structures for implementing algorithms related to test case design. The lecture emphasizes the significance of representing graphs using matrices and lists, specifically, the adjacency matrix and the adjacency list.</p>
</section>
<section id="representation-methods" class="level3">
<h3 class="anchored" data-anchor-id="representation-methods">Representation Methods</h3>
<p>Graphs can be represented using two primary methods: matrices and lists.</p>
<section id="adjacency-list-representation" class="level4">
<h4 class="anchored" data-anchor-id="adjacency-list-representation">Adjacency List Representation</h4>
<p>For each vertex in the graph, an array of lists is employed. This array contains lists corresponding to each vertex, enumerating its adjacent vertices. This representation proves advantageous for sparse graphs where not all vertices have extensive connections.</p>
<section id="example" class="level5">
<h5 class="anchored" data-anchor-id="example">Example</h5>
<p>Consider vertices <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>, and <span class="math inline">\(w\)</span>. The adjacency list representation could be:</p>
<ul>
<li><span class="math inline">\(u\)</span>: {<span class="math inline">\(v\)</span>, <span class="math inline">\(w\)</span>}</li>
<li><span class="math inline">\(v\)</span>: {<span class="math inline">\(u\)</span>, <span class="math inline">\(w\)</span>}</li>
<li><span class="math inline">\(w\)</span>: {<span class="math inline">\(u\)</span>}</li>
</ul>
</section>
</section>
<section id="adjacency-matrix-representation" class="level4">
<h4 class="anchored" data-anchor-id="adjacency-matrix-representation">Adjacency Matrix Representation</h4>
<p>This method utilizes an <span class="math inline">\(n \times n\)</span> matrix, where <span class="math inline">\(n\)</span> is the number of vertices. A 0 or 1 is assigned to each matrix entry based on the presence or absence of an edge between the corresponding vertices.</p>
<section id="example-1" class="level5">
<h5 class="anchored" data-anchor-id="example-1">Example</h5>
<p>For the graph with vertices <span class="math inline">\(u\)</span>, <span class="math inline">\(v\)</span>, and <span class="math inline">\(w\)</span>: <span class="math display">\[
\begin{matrix}
&amp; u &amp; v &amp; w \\
u &amp; 0 &amp; 1 &amp; 1 \\
v &amp; 1 &amp; 0 &amp; 1 \\
w &amp; 1 &amp; 1 &amp; 0 \\
\end{matrix}
\]</span></p>
</section>
</section>
</section>
</section>
<section id="breadth-first-search-bfs" class="level2">
<h2 class="anchored" data-anchor-id="breadth-first-search-bfs">Breadth-First Search (BFS)</h2>
<section id="algorithm-overview" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-overview">Algorithm Overview</h3>
<p>BFS is a traversal algorithm used to explore a graph in a breadth-first manner. The algorithm commences by assigning colors, distances, and parent pointers to vertices. It then employs a queue for traversing the graph, exploring adjacency lists, enqueuing adjacent vertices, and updating attributes.</p>
<section id="bfs-tree" class="level4">
<h4 class="anchored" data-anchor-id="bfs-tree">BFS Tree</h4>
<p>The algorithm constructs a BFS tree, representing the shortest paths from the source vertex. Each edge in the tree corresponds to the shortest path between vertices.</p>
</section>
<section id="queue-operations" class="level4">
<h4 class="anchored" data-anchor-id="queue-operations">Queue Operations</h4>
<p>The BFS algorithm relies on two fundamental operations: enqueue (insert) and dequeue (remove). These operations manage the vertices during the traversal process.</p>
</section>
<section id="vertex-attributes" class="level4">
<h4 class="anchored" data-anchor-id="vertex-attributes">Vertex Attributes</h4>
<ul>
<li><strong>Colors:</strong> Vertices are initially white (unexplored), turn blue when enqueued, and finally black when explored.</li>
<li><strong>Distance Attribute (<span class="math inline">\(d\)</span>):</strong> Represents the length of the shortest path from the source.</li>
<li><strong>Parent Attribute (<span class="math inline">\(\pi\)</span>):</strong> Points to the predecessor vertex in the BFS tree.</li>
</ul>
</section>
</section>
<section id="example-execution-of-bfs" class="level3">
<h3 class="anchored" data-anchor-id="example-execution-of-bfs">Example Execution of BFS</h3>
<p>The lecture provides a step-by-step illustration of BFS execution using a sample graph. It outlines the process of enqueueing, dequeuing, and updating vertex attributes, resulting in the construction of the BFS tree.</p>
</section>
<section id="analysis-of-bfs" class="level3">
<h3 class="anchored" data-anchor-id="analysis-of-bfs">Analysis of BFS</h3>
<p>The efficiency of BFS is analyzed in terms of its running time, which is linear, <span class="math inline">\(O(v + e)\)</span>, where <span class="math inline">\(v\)</span> is the number of vertices and <span class="math inline">\(e\)</span> is the number of edges. BFS guarantees the identification of shortest paths in unweighted graphs.</p>
<section id="correctness-theorem" class="level4">
<h4 class="anchored" data-anchor-id="correctness-theorem">Correctness Theorem</h4>
<p>A correctness theorem is presented, asserting that BFS correctly explores all reachable vertices from the source and returns the shortest paths.</p>
</section>
</section>
</section>
</section>
<section id="depth-first-search-dfs-in-graphs" class="level1">
<h1>Depth First Search (DFS) in Graphs</h1>
<p>Depth First Search (DFS) is an algorithm used for traversing and exploring graphs in a systematic manner. It starts from a designated source vertex and explores as far as possible along each branch before backtracking. This exploration strategy is in contrast to the breadth-first search (BFS) algorithm. DFS provides valuable insights into the structure and connectivity of a graph.</p>
<section id="overview-of-dfs" class="level2">
<h2 class="anchored" data-anchor-id="overview-of-dfs">Overview of DFS</h2>
<p>DFS operates by systematically exploring edges out of the most recently discovered vertex with unexplored edges. The algorithm assigns colors to vertices to track their exploration status:</p>
<ul>
<li><strong>White:</strong> Undiscovered</li>
<li><strong>Gray:</strong> Discovered but not fully explored</li>
<li><strong>Black:</strong> Fully explored</li>
</ul>
<p>Additionally, timestamps in the form of discovery and finish times are assigned to vertices during the process, offering further information about the graph.</p>
<section id="pseudocode-for-dfs" class="level3">
<h3 class="anchored" data-anchor-id="pseudocode-for-dfs">Pseudocode for DFS</h3>
<pre class="plaintext"><code>DFS(G):
  for each vertex u in G:
    color[u] = \text{white}
    parent[u] = \text{nil}
  time = 0
  for each vertex u in G:
    if color[u] is \text{white}:
      DFS-Visit(u)

DFS-Visit(u):
  time = time + 1
  discovery[u] = time
  color[u] = \text{gray}
  for each vertex v adjacent to u:
    if color[v] is \text{white}:
      parent[v] = u
      DFS-Visit(v)
  color[u] = \text{black}
  time = time + 1
  finish[u] = time</code></pre>
</section>
<section id="properties-of-dfs" class="level3">
<h3 class="anchored" data-anchor-id="properties-of-dfs">Properties of DFS</h3>
<ol type="1">
<li><strong>Parenthesis Theorem:</strong>
<ul>
<li>Discovery times are always less than finish times, creating nested parenthesis intervals.</li>
</ul></li>
<li><strong>White Path Theorem:</strong>
<ul>
<li>When first encountering a vertex, there exists a path of white-colored vertices leading to it.</li>
</ul></li>
<li><strong>Edge Classification:</strong>
<ul>
<li><strong>Tree Edges:</strong> Form the DFS tree.</li>
<li><strong>Forward Edges:</strong> Connect descendants to ancestors.</li>
<li><strong>Backward Edges:</strong> Connect ancestors to descendants.</li>
<li><strong>Cross Edges:</strong> Connect vertices unrelated in the DFS tree.</li>
</ul></li>
</ol>
</section>
</section>
</section>
<section id="strongly-connected-components-scc" class="level1">
<h1>Strongly Connected Components (SCC)</h1>
<p>Strongly Connected Components are subsets of vertices in a directed graph where every pair of vertices is reachable from each other. DFS can be employed to efficiently identify these components.</p>
<section id="algorithm-for-scc" class="level2">
<h2 class="anchored" data-anchor-id="algorithm-for-scc">Algorithm for SCC</h2>
<ol type="1">
<li><strong>Run DFS on the graph to compute finish times.</strong>
<ul>
<li>The finish times denote the order in which vertices complete their exploration.</li>
</ul></li>
<li><strong>Compute the transpose of the graph.</strong>
<ul>
<li>Reverse the direction of edges in the graph.</li>
</ul></li>
<li><strong>Run DFS on the transpose graph in reverse finish time order.</strong>
<ul>
<li>Explore vertices in the order of decreasing finish times obtained in step 1.</li>
</ul></li>
<li><strong>Identify SCCs based on DFS trees in the second run.</strong>
<ul>
<li>Each DFS tree represents a strongly connected component.</li>
</ul></li>
</ol>
</section>
</section>
<section id="structural-coverage-criteria-1" class="level1">
<h1>Structural Coverage Criteria</h1>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In the realm of software testing, structural coverage criteria play a pivotal role in ensuring the thorough examination of software artifacts. This lecture delves into various structural coverage criteria applied to graphs, elucidating their significance in the testing process. The focus lies on node coverage, edge coverage, edge pair coverage, and prime path coverage. Additionally, the challenges associated with achieving complete path coverage, especially in the presence of loops, are explored.</p>
</section>
<section id="nodes-edges-and-paths" class="level2">
<h2 class="anchored" data-anchor-id="nodes-edges-and-paths">Nodes, Edges, and Paths</h2>
<p>A graph modeling a software artifact comprises nodes (or vertices) and edges, representing the structural entities. Paths in the graph manifest as sequences of nodes and edges, forming the basis for coverage criteria.</p>
<section id="node-coverage" class="level3">
<h3 class="anchored" data-anchor-id="node-coverage">Node Coverage</h3>
<p><strong>Definition</strong>: The test requirement for node coverage entails generating test cases that visit every node in the graph at least once. A test set, denoted as <span class="math inline">\(T\)</span>, satisfies node coverage if, for every reachable node, there exists a test path in <span class="math inline">\(T\)</span> that visits that node.</p>
</section>
<section id="edge-coverage" class="level3">
<h3 class="anchored" data-anchor-id="edge-coverage">Edge Coverage</h3>
<p><strong>Definition</strong>: Edge coverage necessitates visiting every edge in the graph at least once. The test requirement can be expressed as executing each reachable path of length up to 1. It aims to subsume node coverage, ensuring that the paths of length 0 (nodes) and length 1 (edges) are covered.</p>
</section>
<section id="edge-pair-coverage" class="level3">
<h3 class="anchored" data-anchor-id="edge-pair-coverage">Edge Pair Coverage</h3>
<p><strong>Definition</strong>: This criterion extends coverage to pairs of edges. Test paths of length 2 (pairs of edges) are considered, ensuring coverage of all possible edge pairs. Edge pair coverage aims to encompass both edge and node coverage.</p>
</section>
</section>
<section id="prime-path-coverage" class="level2">
<h2 class="anchored" data-anchor-id="prime-path-coverage">Prime Path Coverage</h2>
<p>Prime paths are maximal simple paths within a graph, devoid of internal loops. Enumerating prime paths provides an effective coverage criterion, addressing challenges associated with loops in control flow graphs.</p>
<p><strong>Definition</strong>: A prime path is a simple path that is not a proper subpath of any other simple path. It serves as a maximal simple path within the graph.</p>
<section id="touring-with-side-trips-and-detours" class="level3">
<h3 class="anchored" data-anchor-id="touring-with-side-trips-and-detours">Touring with Side Trips and Detours</h3>
<p>To address scenarios where prime paths might necessitate traversing loops, two concepts are introduced:</p>
<ol type="1">
<li><p><strong>Side Trips</strong>:</p>
<ul>
<li><p><strong>Definition</strong>: A test path <span class="math inline">\(p\)</span> tours a subpath <span class="math inline">\(q\)</span> with side trips if every edge in <span class="math inline">\(q\)</span> is also in <span class="math inline">\(p\)</span> in the same order, allowing for the inclusion of a sidetrip as long as it returns to the same node.</p></li>
<li><p><strong>Explanation</strong>: Side trips enable the traversal of a subpath <span class="math inline">\(q\)</span> within the main test path <span class="math inline">\(p\)</span>, ensuring that the edges in <span class="math inline">\(q\)</span> are followed in the same sequence as they appear in <span class="math inline">\(p\)</span>. The key distinction with side trips is that they permit deviations from the main path as long as the path returns to the same node.</p></li>
<li><p><strong>Purpose</strong>: The concept of side trips is particularly useful when dealing with loops in control flow graphs. It allows for the inclusion of loop-related paths within the main test path <span class="math inline">\(p\)</span>, contributing to a more practical and feasible testing scenario.</p></li>
</ul></li>
<li><p><strong>Detours</strong>:</p>
<ul>
<li><p><strong>Definition</strong>: A test path <span class="math inline">\(p\)</span> tours a subpath <span class="math inline">\(q\)</span> with detours if every node in <span class="math inline">\(q\)</span> is also in <span class="math inline">\(p\)</span> in the same order, permitting detours from the prime path at a successor of a given node.</p></li>
<li><p><strong>Explanation</strong>: Detours facilitate the traversal of a subpath <span class="math inline">\(q\)</span> within the main test path <span class="math inline">\(p\)</span>, ensuring that the nodes in <span class="math inline">\(q\)</span> are visited in the same sequence as they appear in <span class="math inline">\(p\)</span>. Unlike side trips, detours allow for deviations from the main path at specific nodes, returning to the prime path at a successor of the detoured node.</p></li>
<li><p><strong>Purpose</strong>: Similar to side trips, detours offer a mechanism to accommodate loops in control flow graphs during testing. They provide flexibility by allowing the inclusion of paths related to loops, contributing to a more realistic testing approach.</p></li>
</ul></li>
</ol>
<p>These concepts help mitigate infeasibility concerns, allowing for more practical testing scenarios.</p>
</section>
</section>
<section id="round-trip-coverage" class="level2">
<h2 class="anchored" data-anchor-id="round-trip-coverage">Round Trip Coverage</h2>
<p>Round trips are prime paths that commence and culminate at the same node. Coverage criteria for round trips include:</p>
<ul>
<li><p><strong>Simple Round Trip Coverage</strong>: Ensures at least one round trip for each reachable node.</p></li>
<li><p><strong>Complete Round Trip Coverage</strong>: Requires coverage of all possible round trip paths within the graph.</p></li>
</ul>
</section>
</section>
<section id="graphs-for-structural-coverage-criteria" class="level1">
<h1>Graphs for Structural Coverage Criteria</h1>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>This section delves into the meticulous process of deriving test requirements and paths to achieve structural coverage criteria within software testing. The primary focus is on graphs representing software artifacts.</p>
</section>
<section id="structural-coverage-criteria-2" class="level2">
<h2 class="anchored" data-anchor-id="structural-coverage-criteria-2">Structural Coverage Criteria</h2>
<section id="node-coverage-and-edge-coverage" class="level3">
<h3 class="anchored" data-anchor-id="node-coverage-and-edge-coverage">1. Node Coverage and Edge Coverage</h3>
<section id="test-requirements" class="level4">
<h4 class="anchored" data-anchor-id="test-requirements">Test Requirements</h4>
<ul>
<li><strong>Node Coverage:</strong> Set of nodes in the graph.</li>
<li><strong>Edge Coverage:</strong> Set of edges in the graph.</li>
</ul>
</section>
<section id="test-paths" class="level4">
<h4 class="anchored" data-anchor-id="test-paths">Test Paths</h4>
<p>Utilize Breadth-First Search (BFS) from an initial node to cover reachable nodes and edges systematically.</p>
</section>
</section>
<section id="edge-pair-coverage-1" class="level3">
<h3 class="anchored" data-anchor-id="edge-pair-coverage-1">2. Edge Pair Coverage</h3>
<section id="test-requirements-1" class="level4">
<h4 class="anchored" data-anchor-id="test-requirements-1">Test Requirements</h4>
<ul>
<li>All paths of length <span class="math inline">\(2\)</span> in the graph.</li>
</ul>
</section>
<section id="algorithm" class="level4">
<h4 class="anchored" data-anchor-id="algorithm">Algorithm</h4>
<p>Enumerate pairs of edges by traversing nodes and adjacency lists. This involves considering nodes <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, exploring their adjacency lists, and forming pairs <span class="math inline">\(u \to v \to w\)</span>, where <span class="math inline">\(w\)</span> is in the adjacency list of <span class="math inline">\(v\)</span>.</p>
</section>
</section>
<section id="specified-path-coverage" class="level3">
<h3 class="anchored" data-anchor-id="specified-path-coverage">3. Specified Path Coverage</h3>
<section id="test-requirements-2" class="level4">
<h4 class="anchored" data-anchor-id="test-requirements-2">Test Requirements</h4>
<ul>
<li>Set of specified paths provided by a tester.</li>
</ul>
</section>
<section id="algorithm-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-1">Algorithm</h4>
<p>Modify BFS for graphs without loops to achieve specified path coverage. This entails adapting BFS to include specified paths in the traversal.</p>
</section>
</section>
</section>
<section id="prime-path-coverage-1" class="level2">
<h2 class="anchored" data-anchor-id="prime-path-coverage-1">Prime Path Coverage</h2>
<section id="prime-paths" class="level3">
<h3 class="anchored" data-anchor-id="prime-paths">Prime Paths</h3>
<p>Prime paths are defined as maximal simple paths in a graph.</p>
</section>
<section id="test-requirements-3" class="level3">
<h3 class="anchored" data-anchor-id="test-requirements-3">Test Requirements</h3>
<p>Enumerate all prime paths in the graph.</p>
</section>
<section id="prime-path-enumeration-algorithm" class="level3">
<h3 class="anchored" data-anchor-id="prime-path-enumeration-algorithm">Prime Path Enumeration Algorithm</h3>
<section id="algorithm-overview-1" class="level4">
<h4 class="anchored" data-anchor-id="algorithm-overview-1">1. Algorithm Overview</h4>
<ul>
<li>Enumerate simple paths in ascending order of length.</li>
<li>Choose prime paths among the enumerated paths.</li>
</ul>
</section>
<section id="enumeration-process" class="level4">
<h4 class="anchored" data-anchor-id="enumeration-process">2. Enumeration Process</h4>
<ul>
<li>Paths of length <span class="math inline">\(0\)</span> (vertices) are considered, marking unextendable paths with “!”.</li>
<li>Paths of length <span class="math inline">\(1\)</span> (edges) are enumerated, marking unextendable and simple cycle paths with “!” and “*“.</li>
<li>Extension of paths to obtain length <span class="math inline">\(2\)</span> paths is performed, and paths are marked accordingly.</li>
<li>The process continues until paths of length <span class="math inline">\(\text{mod } v - 1\)</span> are reached, with markings indicating path characteristics.</li>
</ul>
</section>
<section id="result" class="level4">
<h4 class="anchored" data-anchor-id="result">3. Result</h4>
<p>Obtain all prime paths as test requirements.</p>
</section>
</section>
</section>
<section id="test-paths-for-prime-path-coverage" class="level2">
<h2 class="anchored" data-anchor-id="test-paths-for-prime-path-coverage">Test Paths for Prime Path Coverage</h2>
<section id="algorithm-overview-2" class="level3">
<h3 class="anchored" data-anchor-id="algorithm-overview-2">Algorithm Overview</h3>
<ul>
<li>Start with the longest prime path.</li>
<li>Extend each path to the initial and final vertices.</li>
<li>Utilize traversal algorithms to extend paths systematically.</li>
</ul>
</section>
<section id="example-2" class="level3">
<h3 class="anchored" data-anchor-id="example-2">Example</h3>
<p>For a graph with multiple loops, initiate the process with the longest prime path and extend it to cover all instances of loops.</p>
</section>
<section id="optimality-challenge" class="level3">
<h3 class="anchored" data-anchor-id="optimality-challenge">Optimality Challenge</h3>
<p>Achieving optimal test paths is generally intractable. Symbolic execution, an advanced technique, can be explored for improved test path generation.</p>
</section>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>The module provide a comprehensive overview of graph basics, control flow graphs, DFS, BFS, graph representation, and structural coverage criteria in the context of software testing. The detailed explanations and examples make these complex topics accessible, emphasizing their significance in designing effective test cases.</p>
<section id="points-to-remember" class="level2">
<h2 class="anchored" data-anchor-id="points-to-remember">Points to Remember</h2>
<ol type="1">
<li><strong>Graph Basics:</strong>
<ul>
<li>Graphs are fundamental data structures with applications in various fields.</li>
<li>Graphs consist of vertices and edges, and their components include degree, control flow graphs, paths, and reachability.</li>
</ul></li>
<li><strong>DFS and BFS:</strong>
<ul>
<li>DFS and BFS are essential algorithms for reachability analysis in graphs.</li>
<li>DFS explores as far as possible before backtracking, while BFS explores level by level.</li>
<li>They play a crucial role in solving reachability problems.</li>
</ul></li>
<li><strong>Graph Representation:</strong>
<ul>
<li>Graphs can be represented using adjacency matrices or lists.</li>
<li>Adjacency list representation is advantageous for sparse graphs.</li>
</ul></li>
<li><strong>Breadth-First Search (BFS):</strong>
<ul>
<li>BFS explores a graph in a breadth-first manner, constructing a BFS tree.</li>
<li>It guarantees the identification of shortest paths in unweighted graphs.</li>
</ul></li>
<li><strong>Depth First Search (DFS):</strong>
<ul>
<li>DFS explores graphs systematically, assigning colors to vertices.</li>
<li>It provides insights into the structure and connectivity of a graph.</li>
</ul></li>
<li><strong>Strongly Connected Components (SCC):</strong>
<ul>
<li>SCCs are subsets of vertices in a directed graph where every pair of vertices is reachable from each other.</li>
<li>DFS is used to efficiently identify SCCs.</li>
</ul></li>
<li><strong>Structural Coverage Criteria:</strong>
<ul>
<li>Node coverage, edge coverage, edge pair coverage, prime path coverage, best effort touring, and round trip coverage are discussed.</li>
<li>These criteria ensure thorough evaluation of software artifacts in testing.</li>
</ul></li>
<li><strong>Test Paths for Prime Path Coverage:</strong>
<ul>
<li>Enumerating prime paths involves considering simple paths in ascending order of length.</li>
<li>The algorithm systematically extends paths to cover initial and final vertices.</li>
</ul></li>
<li><strong>Optimality Challenge:</strong>
<ul>
<li>Achieving optimal test paths is generally intractable.</li>
<li>Symbolic execution is an advanced technique that can be explored for improved test path generation.</li>
</ul></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>